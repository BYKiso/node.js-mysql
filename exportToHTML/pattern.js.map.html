<html>
<head>
<title>pattern.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pattern.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;pattern.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/pattern.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// this is just a very light wrapper around 2 arrays with an offset index</span><span class="s3">\n\n</span><span class="s1">import { GLOBSTAR } from 'minimatch'</span><span class="s3">\n</span><span class="s1">export type MMPattern = string | RegExp | typeof GLOBSTAR</span><span class="s3">\n\n</span><span class="s1">// an array of length &gt;= 1</span><span class="s3">\n</span><span class="s1">export type PatternList = [p: MMPattern, ...rest: MMPattern[]]</span><span class="s3">\n</span><span class="s1">export type UNCPatternList = [</span><span class="s3">\n  </span><span class="s1">p0: '',</span><span class="s3">\n  </span><span class="s1">p1: '',</span><span class="s3">\n  </span><span class="s1">p2: string,</span><span class="s3">\n  </span><span class="s1">p3: string,</span><span class="s3">\n  </span><span class="s1">...rest: MMPattern[],</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">export type DrivePatternList = [p0: string, ...rest: MMPattern[]]</span><span class="s3">\n</span><span class="s1">export type AbsolutePatternList = [p0: '', ...rest: MMPattern[]]</span><span class="s3">\n</span><span class="s1">export type GlobList = [p: string, ...rest: string[]]</span><span class="s3">\n\n</span><span class="s1">const isPatternList = (pl: MMPattern[]): pl is PatternList =&gt;</span><span class="s3">\n  </span><span class="s1">pl.length &gt;= 1</span><span class="s3">\n</span><span class="s1">const isGlobList = (gl: string[]): gl is GlobList =&gt; gl.length &gt;= 1</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An immutable-ish view on an array of glob parts and their parsed</span><span class="s3">\n </span><span class="s1">* results</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Pattern {</span><span class="s3">\n  </span><span class="s1">readonly #patternList: PatternList</span><span class="s3">\n  </span><span class="s1">readonly #globList: GlobList</span><span class="s3">\n  </span><span class="s1">readonly #index: number</span><span class="s3">\n  </span><span class="s1">readonly length: number</span><span class="s3">\n  </span><span class="s1">readonly #platform: NodeJS.Platform</span><span class="s3">\n  </span><span class="s1">#rest?: Pattern | null</span><span class="s3">\n  </span><span class="s1">#globString?: string</span><span class="s3">\n  </span><span class="s1">#isDrive?: boolean</span><span class="s3">\n  </span><span class="s1">#isUNC?: boolean</span><span class="s3">\n  </span><span class="s1">#isAbsolute?: boolean</span><span class="s3">\n  </span><span class="s1">#followGlobstar: boolean = true</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">patternList: MMPattern[],</span><span class="s3">\n    </span><span class="s1">globList: string[],</span><span class="s3">\n    </span><span class="s1">index: number,</span><span class="s3">\n    </span><span class="s1">platform: NodeJS.Platform,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!isPatternList(patternList)) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('empty pattern list')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!isGlobList(globList)) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('empty glob list')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (globList.length !== patternList.length) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('mismatched pattern list and glob list lengths')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.length = patternList.length</span><span class="s3">\n    </span><span class="s1">if (index &lt; 0 || index &gt;= this.length) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError('index out of range')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.#patternList = patternList</span><span class="s3">\n    </span><span class="s1">this.#globList = globList</span><span class="s3">\n    </span><span class="s1">this.#index = index</span><span class="s3">\n    </span><span class="s1">this.#platform = platform</span><span class="s3">\n\n    </span><span class="s1">// normalize root entries of absolute patterns on initial creation.</span><span class="s3">\n    </span><span class="s1">if (this.#index === 0) {</span><span class="s3">\n      </span><span class="s1">// c: =&gt; ['c:/']</span><span class="s3">\n      </span><span class="s1">// C:/ =&gt; ['C:/']</span><span class="s3">\n      </span><span class="s1">// C:/x =&gt; ['C:/', 'x']</span><span class="s3">\n      </span><span class="s1">// //host/share =&gt; ['//host/share/']</span><span class="s3">\n      </span><span class="s1">// //host/share/ =&gt; ['//host/share/']</span><span class="s3">\n      </span><span class="s1">// //host/share/x =&gt; ['//host/share/', 'x']</span><span class="s3">\n      </span><span class="s1">// /etc =&gt; ['/', 'etc']</span><span class="s3">\n      </span><span class="s1">// / =&gt; ['/']</span><span class="s3">\n      </span><span class="s1">if (this.isUNC()) {</span><span class="s3">\n        </span><span class="s1">// '' / '' / 'host' / 'share'</span><span class="s3">\n        </span><span class="s1">const [p0, p1, p2, p3, ...prest] = this.#patternList</span><span class="s3">\n        </span><span class="s1">const [g0, g1, g2, g3, ...grest] = this.#globList</span><span class="s3">\n        </span><span class="s1">if (prest[0] === '') {</span><span class="s3">\n          </span><span class="s1">// ends in /</span><span class="s3">\n          </span><span class="s1">prest.shift()</span><span class="s3">\n          </span><span class="s1">grest.shift()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const p = [p0, p1, p2, p3, ''].join('/')</span><span class="s3">\n        </span><span class="s1">const g = [g0, g1, g2, g3, ''].join('/')</span><span class="s3">\n        </span><span class="s1">this.#patternList = [p, ...prest]</span><span class="s3">\n        </span><span class="s1">this.#globList = [g, ...grest]</span><span class="s3">\n        </span><span class="s1">this.length = this.#patternList.length</span><span class="s3">\n      </span><span class="s1">} else if (this.isDrive() || this.isAbsolute()) {</span><span class="s3">\n        </span><span class="s1">const [p1, ...prest] = this.#patternList</span><span class="s3">\n        </span><span class="s1">const [g1, ...grest] = this.#globList</span><span class="s3">\n        </span><span class="s1">if (prest[0] === '') {</span><span class="s3">\n          </span><span class="s1">// ends in /</span><span class="s3">\n          </span><span class="s1">prest.shift()</span><span class="s3">\n          </span><span class="s1">grest.shift()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const p = (p1 as string) + '/'</span><span class="s3">\n        </span><span class="s1">const g = g1 + '/'</span><span class="s3">\n        </span><span class="s1">this.#patternList = [p, ...prest]</span><span class="s3">\n        </span><span class="s1">this.#globList = [g, ...grest]</span><span class="s3">\n        </span><span class="s1">this.length = this.#patternList.length</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The first entry in the parsed list of patterns</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pattern(): MMPattern {</span><span class="s3">\n    </span><span class="s1">return this.#patternList[this.#index] as MMPattern</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* true of if pattern() returns a string</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isString(): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.#patternList[this.#index] === 'string'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* true of if pattern() returns GLOBSTAR</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isGlobstar(): boolean {</span><span class="s3">\n    </span><span class="s1">return this.#patternList[this.#index] === GLOBSTAR</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* true if pattern() returns a regexp</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRegExp(): boolean {</span><span class="s3">\n    </span><span class="s1">return this.#patternList[this.#index] instanceof RegExp</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The /-joined set of glob parts that make up this pattern</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">globString(): string {</span><span class="s3">\n    </span><span class="s1">return (this.#globString =</span><span class="s3">\n      </span><span class="s1">this.#globString ||</span><span class="s3">\n      </span><span class="s1">(this.#index === 0 ?</span><span class="s3">\n        </span><span class="s1">this.isAbsolute() ?</span><span class="s3">\n          </span><span class="s1">this.#globList[0] + this.#globList.slice(1).join('/')</span><span class="s3">\n        </span><span class="s1">: this.#globList.join('/')</span><span class="s3">\n      </span><span class="s1">: this.#globList.slice(this.#index).join('/')))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* true if there are more pattern parts after this one</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasMore(): boolean {</span><span class="s3">\n    </span><span class="s1">return this.length &gt; this.#index + 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The rest of the pattern after this part, or null if this is the end</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rest(): Pattern | null {</span><span class="s3">\n    </span><span class="s1">if (this.#rest !== undefined) return this.#rest</span><span class="s3">\n    </span><span class="s1">if (!this.hasMore()) return (this.#rest = null)</span><span class="s3">\n    </span><span class="s1">this.#rest = new Pattern(</span><span class="s3">\n      </span><span class="s1">this.#patternList,</span><span class="s3">\n      </span><span class="s1">this.#globList,</span><span class="s3">\n      </span><span class="s1">this.#index + 1,</span><span class="s3">\n      </span><span class="s1">this.#platform,</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.#rest.#isAbsolute = this.#isAbsolute</span><span class="s3">\n    </span><span class="s1">this.#rest.#isUNC = this.#isUNC</span><span class="s3">\n    </span><span class="s1">this.#rest.#isDrive = this.#isDrive</span><span class="s3">\n    </span><span class="s1">return this.#rest</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* true if the pattern represents a //unc/path/ on windows</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isUNC(): boolean {</span><span class="s3">\n    </span><span class="s1">const pl = this.#patternList</span><span class="s3">\n    </span><span class="s1">return this.#isUNC !== undefined ?</span><span class="s3">\n        </span><span class="s1">this.#isUNC</span><span class="s3">\n      </span><span class="s1">: (this.#isUNC =</span><span class="s3">\n          </span><span class="s1">this.#platform === 'win32' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">this.#index === 0 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">pl[0] === '' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">pl[1] === '' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof pl[2] === 'string' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!!pl[2] &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof pl[3] === 'string' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!!pl[3])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// pattern like C:/...</span><span class="s3">\n  </span><span class="s1">// split = ['C:', ...]</span><span class="s3">\n  </span><span class="s1">// XXX: would be nice to handle patterns like `c:*` to test the cwd</span><span class="s3">\n  </span><span class="s1">// in c: for *, but I don't know of a way to even figure out what that</span><span class="s3">\n  </span><span class="s1">// cwd is without actually chdir'ing into it?</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the pattern starts with a drive letter on Windows</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isDrive(): boolean {</span><span class="s3">\n    </span><span class="s1">const pl = this.#patternList</span><span class="s3">\n    </span><span class="s1">return this.#isDrive !== undefined ?</span><span class="s3">\n        </span><span class="s1">this.#isDrive</span><span class="s3">\n      </span><span class="s1">: (this.#isDrive =</span><span class="s3">\n          </span><span class="s1">this.#platform === 'win32' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">this.#index === 0 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">this.length &gt; 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof pl[0] === 'string' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">/^[a-z]:$/i.test(pl[0]))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// pattern = '/' or '/...' or '/x/...'</span><span class="s3">\n  </span><span class="s1">// split = ['', ''] or ['', ...] or ['', 'x', ...]</span><span class="s3">\n  </span><span class="s1">// Drive and UNC both considered absolute on windows</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the pattern is rooted on an absolute path</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isAbsolute(): boolean {</span><span class="s3">\n    </span><span class="s1">const pl = this.#patternList</span><span class="s3">\n    </span><span class="s1">return this.#isAbsolute !== undefined ?</span><span class="s3">\n        </span><span class="s1">this.#isAbsolute</span><span class="s3">\n      </span><span class="s1">: (this.#isAbsolute =</span><span class="s3">\n          </span><span class="s1">(pl[0] === '' &amp;&amp; pl.length &gt; 1) ||</span><span class="s3">\n          </span><span class="s1">this.isDrive() ||</span><span class="s3">\n          </span><span class="s1">this.isUNC())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* consume the root of the pattern, and return it</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">root(): string {</span><span class="s3">\n    </span><span class="s1">const p = this.#patternList[0]</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">typeof p === 'string' &amp;&amp; this.isAbsolute() &amp;&amp; this.#index === 0</span><span class="s3">\n      </span><span class="s1">) ?</span><span class="s3">\n        </span><span class="s1">p</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Check to see if the current globstar pattern is allowed to follow</span><span class="s3">\n   </span><span class="s1">* a symbolic link.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">checkFollowGlobstar(): boolean {</span><span class="s3">\n    </span><span class="s1">return !(</span><span class="s3">\n      </span><span class="s1">this.#index === 0 ||</span><span class="s3">\n      </span><span class="s1">!this.isGlobstar() ||</span><span class="s3">\n      </span><span class="s1">!this.#followGlobstar</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Mark that the current globstar pattern is following a symbolic link</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">markFollowGlobstar(): boolean {</span><span class="s3">\n    </span><span class="s1">if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">this.#followGlobstar = false</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>